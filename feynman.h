#ifndef FEYNMAN_H
#define FEYNMAN_H

#include "fixedpoint.h"

// https://en.wikipedia.org/wiki/Logarithm#Feynman's_algorithm

/* Keep shifting until it is 1 <= x < 2
   Use the same 2.30 representation as below.
   Note that we are shifting up, so no precision is lost in this step.
*/




/* Limited range logarithm.
   1 =< argument < 2  in 2.30 fixed point.
   0 =< log      < 1  in 0.32 fixed point.

   Which is the intended use of this function, but the result depends
   on the table, expected to be in 0.32 fixed point.

   The k index for the 1+2^(-k) runs from 1 up to and including precision.
   The table is 0-based, the first entry is for k==1
*/

/* Max 30 bits */
#define FEYNMAN_SHIFT 30
#define FEYNMAN_ONE (1 << FEYNMAN_SHIFT)
#define FEYNMAN_TWO (1 << (FEYNMAN_SHIFT + 1))

static inline uint32_t feynman_log_12(uint32_t *table, uint32_t precision, uint32_t argument) {
    const int32_t one = FEYNMAN_ONE;
    uint32_t acc = 0;
    uint32_t prod = one;
    for (uint32_t k=1; k<=precision; k++) {
        uint32_t factor = one + (one >> k);
        uint32_t prod_k = (U64(prod) * U64(factor)) >> FEYNMAN_SHIFT;
        if (prod_k < argument) {
            prod = prod_k;
            acc += table[k-1];
        }
    }
    return acc;
}

/* Range shift. */
static int32_t feynman_reduce(uint32_t argument) {
    /* There's only one possibility in this range. */
    if (argument >= FEYNMAN_TWO) {
        return 1;
    }
    int32_t n = 0;
    while(argument < FEYNMAN_ONE) {
        n--;
        argument <<= 1;
    }
    return n;
}
/* Full range < 4 in 2.30 fixed point.

   This is a little awkward in fixed point, so we leave
   it up to the caller how much headroom to leave.  FIXME: Saturate
   the result instead of producing garbage. */

#include <stdio.h>

static inline int32_t feynman_log(uint32_t *table, uint32_t precision, uint32_t headroom, uint32_t argument) {
    int32_t  coarse = feynman_reduce(argument);
    uint32_t argument_s = (coarse >= 0) ? (argument >> coarse) : (argument << -coarse);
    uint32_t fine = feynman_log_12(table, precision, argument_s) >> headroom;
    //printf("a=%d, n=%d, ns=%d, l=%d -- ", argument, n, ns, l);
    return fine + (coarse << (32 - headroom));
}


/* Generated by test_feynman.c */

/* 0.32 bit fixed point [0,1[ */
#define FEYNMAN_TABLE_INIT \
    /* 1+2^-1 */ [0] = 2512394809,\
    /* 1+2^-2 */ [1] = 1382670639,\
    /* 1+2^-3 */ [2] = 729822323,\
    /* 1+2^-4 */ [3] = 375650042,\
    /* 1+2^-5 */ [4] = 190671290,\
    /* 1+2^-6 */ [5] = 96069025,\
    /* 1+2^-7 */ [6] = 48220694,\
    /* 1+2^-8 */ [7] = 24157254,\
    /* 1+2^-9 */ [8] = 12090399,\
    /* 1+2^-10 */ [9] = 6048148,\
    /* 1+2^-11 */ [10] = 3024812,\
    /* 1+2^-12 */ [11] = 1512590,\
    /* 1+2^-13 */ [12] = 756341,\
    /* 1+2^-14 */ [13] = 378182,\
    /* 1+2^-15 */ [14] = 189094,\
    /* 1+2^-16 */ [15] = 94547,\
    /* 1+2^-17 */ [16] = 47274,\
    /* 1+2^-18 */ [17] = 23637,\
    /* 1+2^-19 */ [18] = 11818,\
    /* 1+2^-20 */ [19] = 5909,\
    /* 1+2^-21 */ [20] = 2954,\
    /* 1+2^-22 */ [21] = 1477,\
    /* 1+2^-23 */ [22] = 738,\
    /* 1+2^-24 */ [23] = 369,\
    /* 1+2^-25 */ [24] = 184,\
    /* 1+2^-26 */ [25] = 92,\
    /* 1+2^-27 */ [26] = 46,\
    /* 1+2^-28 */ [27] = 23,\
    /* 1+2^-29 */ [28] = 11,\
    /* 1+2^-30 */ [29] = 5,\
    /* 1+2^-31 */ [30] = 2,\
    /* 1+2^-32 */ [31] = 1,\

#endif
