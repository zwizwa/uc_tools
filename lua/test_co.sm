#lang s-expr "sm.rkt" ;; -*- scheme -*-

;; Test simpler co-routine abstraction.
(define (prog1 chan)
  (define (fun1)
    (co chan
        (let* ((a (co chan 1)))
          (add a (co chan 2))))
    (yield)
    (fun1)
    )
  (fun1))

(define (prog2 chan)
  (define (main)
    (let* ((x (read chan)))
      (write chan (add x 1))
      (main)))
  (main))

          
;(define (fun2 x)
;  (yield)
;  (fun1))

;; I'd like to use the following story to act as a design guide to
;; give this the proper semantics:
;;
;; This scheme program is started.  It performs some initialization
;; and then spawns a number of tasks that wait for events to happen.
;; Before any events happen, the memory image is serialized to disk,
;; the machine is turned off, then the machine is turned on again, the
;; memory image is loaded again and the program is resumed.
;;
;; Now replace "memory image" with "generated C program", and replace
;; the single machine with a host machine that runs the scheme program
;; to generate the C program, and a target machine that runs the
;; compiled C program as if it was resuming a memory image.  I.e. the
;; generated C program can contain some static data structures that
;; would be the result of executing the start function.
;;
;; This is quite close to the meaning of a non-staged Scheme program
;; with the restriction that the start function can not be referenced
;; by the code that implements the task network.

(define (start)
  (let* ((c (make-channel)))
    (spawn! (lambda () (prog1 c)))
    (spawn! (lambda () (prog2 c)))
    ))
