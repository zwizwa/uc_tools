#lang s-expr "sm.rkt" ;; -*- scheme -*-

;; Test simpler co-routine abstraction.
(define (prog1 self other)
  (define (fun1)
    (co other 123)
    (fun1))
  (fun1))

          
;(define (fun2 x)
;  (yield)
;  (fun1))

;; I'd like to use the following story to act as a design guide to
;; give this the proper semantics:
;;
;; This scheme program is started.  It performs some initialization
;; and then spawns a number of tasks that wait for events to happen.
;; Before any events happen, the memory image is serialized to disk,
;; the machine is turned off, then the machine is turned on again, the
;; memory image is loaded again and the program is resumed.
;;
;; Now replace "memory image" with "generated C program", and replace
;; the single machine with a host machine that runs the scheme program
;; to generate the C program, and a target machine that runs the
;; compiled C program as if it was resuming a memory image.  I.e. the
;; generated C program can contain some static data structures that
;; would be the result of executing the start function.
;;
;; This is quite close to the meaning of a non-staged Scheme program
;; with the restriction that the start function can not be referenced
;; by the code that implements the task network.

(define (start)
  (let* ((task1 (make-task))
         (task2 (make-task)))
    (spawn! (lambda () (prog1 task1 task2)))
    ))
