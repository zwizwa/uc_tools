#ifndef FIXEDPOINT_LOG_H
#define FIXEDPOINT_LOG_H

#include "fixedpoint.h"

// https://en.wikipedia.org/wiki/Logarithm#Feynman's_algorithm

/* Keep shifting until it is 1 <= x < 2
   Use the same 2.30 representation as below.
   Note that we are shifting up, so no precision is lost in this step.
*/




/* Successive approximation routine, limited range.  Input is:
   1 =< argument < 2  in 2.30 fixed point.

   Output is
   0 =< log      < 1  in 0.32 fixed point.

   And is computed from table, which contains 0.32 fixed point.

   The k index for the 1+2^(-k) runs from 1 up to and including precision.
   The table is 0-based, the first entry is for k==1
*/

/* Max 30 bits */
#define FEYNMAN_SHIFT 30
#define FEYNMAN_ONE (1 << FEYNMAN_SHIFT)
#define FEYNMAN_TWO (1 << (FEYNMAN_SHIFT + 1))

static inline uint32_t feynman_log_1_2(uint32_t *table, uint32_t precision, uint32_t arg_2_30) {
    const int32_t one = FEYNMAN_ONE;
    uint32_t acc = 0;
    uint32_t prod = one;
    for (uint32_t k=1; k<=precision; k++) {
        uint32_t factor = one + (one >> k);
        uint32_t prod_k = (U64(prod) * U64(factor)) >> FEYNMAN_SHIFT;
        if (prod_k < arg_2_30) {
            prod = prod_k;
            acc += table[k-1];
        }
    }
    return acc;
}

#include <stdio.h>

/* Returns negative log in 5.27 fixed point format for arg < 1 in 0.32
   fixed point format. */
static inline uint32_t feynman_nlog_5_27(
    uint32_t *table,
    uint32_t precision,  // number of table entries
    uint32_t arg) {      // 0.32 fixed point number

    const uint32_t point = 5;
    const uint32_t one = 1 << (32 - point);

    /* Clip gracefully near the pole to the max value. */
    if (arg <= 2) return (31 * one);

    /* Scale argument to max out mantissa. */
    uint32_t coarse = 0;
    while (arg < 0x80000000) { coarse += one; arg <<= 1; }

    /* Arg is now [0,5,1[ in 0.32 fixed point.
       Shift it into the correct range for the core routine. */
    arg >>= 1;
    uint32_t fine = feynman_log_1_2(table, precision, arg) >> point;

    /* Return negative log, compensating for the core routine assuming
       the value is [1,2[ while it is in fact [0.5,1[, so the log is
       one less, or the negative log is one more.. */
    return coarse - fine + one;
}


/* Note that 5 bits are thrown away to make room for the integral
   part, so we can truncate the table below that. */
#define FEYNMAN_PRECISION 27

/* Generated by test_feynman.c */

/* 0.32 bit fixed point [0,1[ */
#define FEYNMAN_TABLE_INIT \
    /* 1+2^-1 */ [0] = 2512394809,\
    /* 1+2^-2 */ [1] = 1382670639,\
    /* 1+2^-3 */ [2] = 729822323,\
    /* 1+2^-4 */ [3] = 375650042,\
    /* 1+2^-5 */ [4] = 190671290,\
    /* 1+2^-6 */ [5] = 96069025,\
    /* 1+2^-7 */ [6] = 48220694,\
    /* 1+2^-8 */ [7] = 24157254,\
    /* 1+2^-9 */ [8] = 12090399,\
    /* 1+2^-10 */ [9] = 6048148,\
    /* 1+2^-11 */ [10] = 3024812,\
    /* 1+2^-12 */ [11] = 1512590,\
    /* 1+2^-13 */ [12] = 756341,\
    /* 1+2^-14 */ [13] = 378182,\
    /* 1+2^-15 */ [14] = 189094,\
    /* 1+2^-16 */ [15] = 94547,\
    /* 1+2^-17 */ [16] = 47274,\
    /* 1+2^-18 */ [17] = 23637,\
    /* 1+2^-19 */ [18] = 11818,\
    /* 1+2^-20 */ [19] = 5909,\
    /* 1+2^-21 */ [20] = 2954,\
    /* 1+2^-22 */ [21] = 1477,\
    /* 1+2^-23 */ [22] = 738,\
    /* 1+2^-24 */ [23] = 369,\
    /* 1+2^-25 */ [24] = 184,\
    /* 1+2^-26 */ [25] = 92,\
    /* 1+2^-27 */ [26] = 46,\

#endif
