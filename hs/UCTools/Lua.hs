-- Keep track of the point of this, because I am getting lost in the
-- weeds again: I want to create a DSL that can produce Lua (and
-- JavaScript) code.  The interpreter here is mainly to be able to
-- test the code generated by that DSL, and in addition some uc_tools
-- and client Lua code.


-- NEXT:
-- . convert internal table rep back to printable lua inside monad
-- . write more code in test_lua_hs.lua and fill in the interpreter
-- . represent functions as code or syntax?
-- . SelectName (PEVar (SelectName (PEVar (VarName (Name "m"))) (Name "test"))) (Name "a") VInt 456

-- TODO: Tables really need to be accessed by reference.  It is not
-- enough to just add an id.


-- Lua tools.  Goals:
-- . Static analysis of code written in Lua (parse, eval)
-- . A tagless final DSL to generate Lua code (compile, pretty)


-- Evaluator is mostly about how to handle local and global variables.
-- I think I'm just going to use a State monad with two maps for this,
-- with the local map being reset during sub-block execution.



-- https://hackage.haskell.org/package/language-lua

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TemplateHaskell #-}

module UCTools.Lua where

import Language.Lua
import Control.Monad.Writer
import qualified Control.Monad.State as State
import Control.Monad.Fix
import Data.Map
import Data.Maybe
import Data.IntMap
import Data.List
import Control.Lens
import Prelude hiding (log)
import Data.Text
import Data.Text.Read
import Text.Pretty.Simple

type Table = Map Value Value
data Value = VFloat Float
           | VInt Int
           | VBool Bool
           | VString Text
           | VNil
           | VNI String
           | VPtr Int
           deriving (Show, Eq, Ord)

-- Tables and functions are compared by reference, and tables can be
-- updated in-place.  I don't see a way to avoid putting them in a
-- store.  I also don't see how I can avoid then manually implementing
-- GC on that store.
data Object = OTable Table
            | OFun   Bool Table FunBody
            deriving (Show, Eq)

-- I think that 

data State    = State {
  _nextId  :: Int,
  _objects :: IntMap Object
  } deriving (Show)
data Result t = Result State Log t deriving (Show)

type Log = String

newtype EvalM t = EvalM (WriterT Log (State.State State) t)
                deriving (Functor, Applicative, Monad,
                          MonadFix,
                          MonadWriter Log,
                          State.MonadState State)

$(makeLenses ''State)

log = tell
logn = log . (++ "\n")

instance MonadFail EvalM where
  fail msg = error $ "EvalM:fail:" ++ msg
  

-- Tables are stored in the objects IntMap and use indirection.
setTableField :: Int -> Value -> Value -> EvalM ()
setTableField id k v = do
  -- objects %= Data.IntMap.adjust id (Data.Map.insert key val)
  -- FIXME: This unrap/rewrap can be done with lenses as well
  -- The fmap is for Maybe
  -- objects . at id %= fmap (\(OTable t) -> OTable $ Data.Map.insert k v t)
  -- I do need a match error when the Table at id doesn't exist.
  objects . at id %= \(Just (OTable t)) -> Just $ OTable $ Data.Map.insert k v t


setTableFields :: Int -> [Value] -> Value -> EvalM ()
setTableFields id [field] val =
  setTableField id field val
setTableFields id (field : fields) val = do
  (VPtr id') <- getTableField id field
  setTableFields id' fields val



getTable :: Int -> EvalM Table
getTable id = do
  Just (OTable t) <- use (objects . at id)
  return t

getTableField :: Int -> Value -> EvalM Value
getTableField id k = do
  t <- getTable id
  case Data.Map.lookup k t of
    Just v  -> return v
    Nothing -> return VNil

getLocals  = getTable locals
getGlobals = getTable globals

setTable :: Int -> Table -> EvalM ()
setTable id tab = do
  objects . at id .= (Just $ OTable tab)

setLocals  = setTable locals
setGlobals = setTable globals

setLocal  = setTableField locals  . VString
setGlobal = setTableField globals . VString

getLocal  = getTableField locals  . VString
getGlobal = getTableField globals . VString

setVar :: Text -> Value -> EvalM ()
setVar name val = do
  -- logn $ "setVar " ++ show name ++ " " ++ show val
  l <- getLocal name
  case l of
    VNil -> setGlobal name val
    _    -> setLocal  name val


setVarPath :: Name -> [Name] -> Value -> EvalM ()
setVarPath (Name name) [] val = setVar name val
setVarPath (Name name) fields val = do
  tab <- getVar name
  case tab of
    VNil    -> error "setVarPath table doesn't exist"
    VPtr id -> setTableFields id (names2values fields) val

names2values :: [Name] -> [Value]
names2values = fmap $ \(Name name) -> VString name
    

getVar :: Text -> EvalM Value
getVar name = do
  l <- getLocal name
  case l of
    VNil -> getGlobal name
    _    -> return l
      
evalBlock block@(Block stats maybeReturn) = do
  -- logn $ show block
  locals' <- getLocals
  traverse evalStat stats
  rvs <- case maybeReturn of
    Nothing -> return [VNil]
    Just exprs -> do
      -- FIXME: Semantics not clear, how do multiple return values
      -- combine?  Also: nil seems to abort concatentation.  Find a
      -- reference or work by testing against reference interpreter.
      vals <- traverse evalExp exprs
      return $ Prelude.concat vals
  setLocals locals'
  return rvs

unName (Name n) = n
unNames = fmap unName
namesToPath = fmap (VString . unName)

traverse' = flip traverse

makeTable t = do
  id <- use nextId
  nextId %= (+ 1)
  objects %= Data.IntMap.insert id (OTable t)
  return id

makeFun :: Bool -> FunBody -> EvalM Int
makeFun hasSelf body = do
  env <- getLocals
  id <- use nextId
  nextId %= (+ 1)
  objects %= Data.IntMap.insert id (OFun hasSelf env body)
  return id

    
  
evalStat stat = do
  -- log $ show stat
  let ni str = logn $ "Stat not implemented: " ++ str

      ev (Label name) = ni "Label"
      ev Break = ni "Break"
      ev (Goto name) = ni "Goto"
      ev (Do block) = ni "Do"
      ev (While exp block) = ni "While"
      ev (Repeat block exp) = ni "Repeat"
      ev (If expBlocks maybeElse) = ni "If"
      ev (ForRange name expr exp maybeExp block) = ni "ForRange"
      ev (ForIn names exprs block) = ni "ForIn"

      ev EmptyStat = return ()

      ev (FunCall funCall) = do
        evalFunCall funCall
        return ()
  
      ev ex@(FunAssign (FunName name names maybeName) body) = do
        (fieldNames, hasSelf) <-
          case maybeName of
            Nothing -> do
              return $ (names ++ [],  True)
            Just n  -> do
              return $ (names ++ [n], False)
        id <- makeFun hasSelf body
        setVarPath name fieldNames $ VPtr id
          
      ev ex@(LocalFunAssign (Name name) body) = do
        -- logn $ "LocalFunAssign: " ++ show ex
        id <- makeFun False body
        setLocal name $ VPtr id
        
      ev ex@(LocalAssign names maybeExps) = do
        -- logn $ "LocalAssign: " ++ show ex
        vals' <- case maybeExps of
          Just exps ->
            traverse evalExp exps
          Nothing ->
            -- FIXME: Not clear.  All nil?
            return $ cycle [[VNil]]
        let vals = Prelude.concat vals'
            -- FIXME: Zip vars with values correct?
            nvs = Prelude.zip names vals 
        traverse' nvs $ \(Name name, val) -> setLocal name val
        return ()

      ev ex@(Assign vars exps) = do
        -- logn $ "Assign: " ++ show ex
        vals <- traverse evalExp exps
        let assign' (var, val) = assignVar var val
        traverse assign' $ Prelude.zip vars $ Prelude.concat vals
        return ()
      
  ev stat

assignVar (VarName (Name var)) val = setVar var val
assignVar (Select table key) val = do
  [VPtr id] <- evalPrefixExp table
  [key'] <- evalExp key
  setTableField id key' val
assignVar (SelectName table (Name field)) val = do
  [VPtr id] <- evalPrefixExp table
  setTableField id (VString field) val

-- Variables can only have one value.  Function calls can have
-- multiple.  This is awkward.  It seems simples to always use [Value]
-- instead of Value as eval return value.
evalVar :: Var -> EvalM [Value]
evalVar var@(VarName (Name name)) = do
  val <- getVar name
  return [val]
evalVar (SelectName table (Name field)) = do
  [VPtr id] <- evalPrefixExp table
  val <- getTableField id (VString field)
  return [val]

evalFunCall (NormalFunCall fun args) = do
  [VPtr idFun] <- evalPrefixExp fun
  evalFun idFun Nothing args

evalFunCall (MethodCall table (Name field) args) = do
  [self@(VPtr idTable)] <- evalPrefixExp table
  VPtr idFun <- getTableField idTable (VString field) 
  evalFun idFun (Just self) args

evalFun idFun maybeSelf args = do
  -- FIXME: hasSelf
  -- FIXME: vararg
  -- FIXME: What is semantics of argument inlining for multiple return
  -- values into argument list?
  Just (OFun hasSelf capturedEnv
        (FunBody names vararg block)) <- use (objects . at idFun)
  args' <- case args of
    (Args as) -> traverse evalExp as
    -- TableArg
    -- StringArg
  let
    args'' = Prelude.concat (maybeToList maybeSelf : args')

  -- Switch environment and define argument bindings.
  locals' <- getLocals
  setLocals capturedEnv
  let setArg (Name name, val) = setLocal name val
  traverse setArg $ Prelude.zip names args''
  -- Evaluate the body code in the new environment.
  rvs <- evalBlock block
  -- Switch back to call site environment
  setLocals locals'
  return rvs

evalPrefixExp pexp =
  case pexp of
    PEVar v      -> evalVar v
    Paren e      -> evalExp e
    PEFunCall fc -> evalFunCall fc

toFloat :: Value -> Float
toFloat (VFloat f) = f
toFloat (VInt i) = fromIntegral i
toFloat v = error $ "toFloat " ++ show v
  
  

evalExp :: Exp -> EvalM [Value]  
evalExp expr = do
  -- log $ show expr
  let ni str = do logn $ "Expr not implemented: " ++ str ; return [VNI str]

      ev Vararg = ni "Vararg"

      ev Nil = return [VNil]
      ev (Bool b) = return [VBool b]
      ev (String text) = return [VString text]

      ev (EFunDef body) = do
        id <- makeFun False body
        return [VPtr id]

      ev (Binop binop e1 e2) = do
        [e1'] <- evalExp e1
        [e2'] <- evalExp e2
        let ops = case binop of
              Add -> ((+),(+))
              Sub -> ((-),(-))
              Mul -> ((*),(*))
              _ -> error "FIXME Binop"
            -- Note that Lua 5.3 uses integers.
            eval2op (opI,_) (VInt a) (VInt b) = VInt $ opI a b
            eval2op (_,opF) a b = VFloat $ opF (toFloat a) (toFloat b)
            val = eval2op ops e1' e2'
        return [val]

      ev (Unop unop e) = do
        [e'] <- evalExp e
        let neg x = -x
            ops = case unop of
              Neg -> (neg,neg)
              _ -> error "FIXME Unop"
            eval1op (opI,_) (VInt a) = VInt $ opI a
            eval1op (_,opF) a = VFloat $ opF (toFloat a)
            val = eval1op ops e'
        return [val]
            
      ev ex@(Number IntNum text) = do
        -- FIXME use Data.Text.Read
        let Right (n, _) = decimal text
        return [ VInt n ]

      ev (PrefixExp pexp) = evalPrefixExp pexp

      ev (TableConst tableFields) = do
        -- [1..] as ExpField.  Then traverse evalExp and store as map.
        let -- Array fields and keyed fields are handled separately
            isField (Field _) = True ; isField _ = False
            (arrFields',keyFields) = Data.List.partition isField tableFields
            arrFields = Prelude.zip [1..] arrFields'

            -- Array values
            indexed :: (Int, TableField) -> EvalM (Value, Value)
            indexed (i, Field v) = do
              [v'] <- evalExp v
              return (VInt i, v')

            keyed :: TableField -> EvalM (Value, Value)
            keyed (NamedField (Name k) v) = do
              [v'] <- evalExp v
              return (VString k, v')
            keyed (ExpField k v) = do
              [k'] <- evalExp k
              [v'] <- evalExp v
              return (k', v')

        assIndexed <- traverse indexed arrFields
        assKeyed   <- traverse keyed   keyFields
        id <- makeTable $ Data.Map.fromList $ assIndexed ++ assKeyed  
        return $ [ VPtr id ]
        
  ev expr



-- Convert evaluator data structure back to syntax.
serialize (VFloat f) = return $ Number FloatNum $ pack $ show f
serialize (VInt i) = return $ Number IntNum $ pack $ show i
serialize (VString s) = return $ String $ pack $ show s -- FIXME: same quoting?
serialize VNil = return $ Nil
serialize (VPtr id) = do
  Just obj <- use (objects . at id)
  case obj of
    (OTable table) -> do
      let field (key, val) = do
            val' <- serialize val
            -- FIXME: would be nice to also render Field but that is
            -- not strictly necessary at this point.
            case key of
              (VString name) -> do
                return $ NamedField (Name name) val'
              _ -> do
                key' <- serialize key
                return $ ExpField key' val'

      fields <- traverse field $ Data.Map.toList table
      return $ TableConst fields
    -- FIXME: Also serialize the environment
    (OFun True env (FunBody names vararg block)) -> do
      return $ EFunDef (FunBody (Name "self":names) vararg block)
    (OFun False env body) -> do
      return $ EFunDef body


-- The result of parseFile is a Block.  It seems best to focus on the
-- file level.

-- These can just be hardcoded
globals = 0
locals  = 1

runM :: EvalM t -> Result t
runM (EvalM m) = Result s l v where
  obj0 = Data.IntMap.fromList [
    (globals, OTable mempty),
    (locals,  OTable mempty)
    ]
  s0 = State 2 obj0
  ((v, l), s) = State.runState (runWriterT m) s0


pp = pPrintNoColor

test1 = do
  putStrLn "** test1"
  rv <- parseFile "../lua/test_lua_hs.lua"
  case rv of
    Right block -> do
      -- let (Result state log rv) = runM $ evalBlock block
      let (Result state log (rvs, stxs)) = runM $ do
            luaVals <- evalBlock block
            luaStxs <- traverse serialize luaVals
            return (luaVals, luaStxs)
      putStr $ log
      pp state
      pp rvs
      pp stxs
      traverse' stxs $ \stx -> do
        putStrLn $ show $ pprint stx
      return ()
      
    Left (sourceRange, msg) -> do
      putStrLn $ show sourceRange
      putStrLn $ msg

