-- Keep track of the point of this, because I am getting lost in the
-- weeds again: I want to create a DSL that can produce Lua (and
-- JavaScript) code.  The interpreter here is mainly to be able to
-- test the code generated by that DSL, and in addition some uc_tools
-- and client Lua code.

-- The other thing is a Lua to Javascript compiler.  Might work with a
-- subset of Lua, e.g. one that doesn't support multiple return values
-- etc.  But altogether might be simpler to just embed it in the
-- Electron app.




-- NEXT:
-- . write more code in test_lua_hs.lua and fill in the interpreter

-- TODO: Tables really need to be accessed by reference.  It is not
-- enough to just add an id.


-- Lua tools.  Goals:
-- . Static analysis of code written in Lua (parse, eval)
-- . A tagless final DSL to generate Lua code (compile, pretty)


-- Evaluator is mostly about how to handle local and global variables.
-- I think I'm just going to use a State monad with two maps for this,
-- with the local map being reset during sub-block execution.



-- https://hackage.haskell.org/package/language-lua

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE RecursiveDo #-}
{-# LANGUAGE BangPatterns #-}

{-# LANGUAGE RankNTypes #-}

module UCTools.Lua where

import Language.Lua
import Control.Monad.Writer
import qualified Control.Monad.State as State
import Control.Monad
import Control.Monad.Fix
import Data.Map
import Data.Maybe
import Data.IntMap
import Data.List
import Control.Lens
import Prelude hiding (log, GT, EQ)
import Data.Text
import Data.Text.Read
import Text.Pretty.Simple

type Table = Map Value Value
data Value = VFloat Float
           | VInt Int
           | VBool Bool
           | VString Text
           | VNil
           | VNI String
           | VPtr Int
           deriving (Show, Eq, Ord)

-- Tables and functions are compared by reference, and tables can be
-- updated in-place.  I don't see a way to avoid putting them in a
-- store.  I also don't see how I can avoid then manually implementing
-- GC on that store.
data Object = OTable Table
            | OFun   Table FunBody
            deriving (Show, Eq)

-- I think that 

data State = State {
  _nextId  :: Int,
  _objects :: IntMap Object
  } deriving (Show)
data Result t = Result State Log t deriving (Show)

type Log = String

newtype EvalM t = EvalM (WriterT Log (State.State State) t)
                deriving (Functor, Applicative, Monad,
                          MonadFix,
                          MonadWriter Log,
                          State.MonadState State)

$(makeLenses ''State)

log = tell
logn = log . (++ "\n")

instance MonadFail EvalM where
  fail msg = error $ "EvalM:fail:" ++ msg
  

-- Tables are stored in the objects IntMap and use indirection.
setTableField :: Int -> Value -> Value -> EvalM ()
setTableField id k v = do
  -- objects %= Data.IntMap.adjust id (Data.Map.insert key val)
  -- FIXME: This unrap/rewrap can be done with lenses as well
  -- The fmap is for Maybe
  -- objects . at id %= fmap (\(OTable t) -> OTable $ Data.Map.insert k v t)
  -- I do need a match error when the Table at id doesn't exist.
  objects . at id %= \(Just (OTable t)) -> Just $ OTable $ Data.Map.insert k v t


setTableFields :: Int -> [Value] -> Value -> EvalM ()
setTableFields id [field] val =
  setTableField id field val
setTableFields id (field : fields) val = do
  (VPtr id') <- getTableField id field
  setTableFields id' fields val



getTable :: Int -> EvalM Table
getTable id = do
  Just (OTable t) <- use (objects . at id)
  return t

getTableField :: Int -> Value -> EvalM Value
getTableField id k = do
  t <- getTable id
  case Data.Map.lookup k t of
    Just v  -> return v
    Nothing -> return VNil

getLocals  = getTable locals
getGlobals = getTable globals

setTable :: Int -> Table -> EvalM ()
setTable id tab = do
  objects . at id .= (Just $ OTable tab)

setLocals  = setTable locals
setGlobals = setTable globals

setLocal  = setTableField locals  . VString
setGlobal = setTableField globals . VString

getLocal  = getTableField locals  . VString
getGlobal = getTableField globals . VString

setVar :: Text -> Value -> EvalM ()
setVar name val = do
  -- logn $ "setVar " ++ show name ++ " " ++ show val
  l <- getLocal name
  case l of
    VNil -> setGlobal name val
    _    -> setLocal  name val


setVarPath :: Name -> [Name] -> Value -> EvalM ()
setVarPath (Name name) [] val = setVar name val
setVarPath (Name name) fields val = do
  tab <- getVar name
  case tab of
    VNil    -> error "setVarPath table doesn't exist"
    VPtr id -> setTableFields id (names2values fields) val

names2values :: [Name] -> [Value]
names2values = fmap $ \(Name name) -> VString name
    

getVar :: Text -> EvalM Value
getVar name = do
  l <- getLocal name
  case l of
    VNil -> getGlobal name
    _    -> return l


-- FIXME: return is function return, not block return!
evalBlock block@(Block stats maybeReturn) = do
  -- logn $ show block
  locals' <- getLocals
  traverse evalStat stats
  rvs <- case maybeReturn of
    Nothing -> return [VNil]
    Just exprs -> do
      vals <- traverse evalExp exprs
      return $ luaConcat vals
  stripLocals locals'
  return rvs

-- After block execution the key set is restored but the values should
-- be updated.
stripLocals savedLocals = do
  locals' <- getLocals
  let tab = Data.Map.mapWithKey f savedLocals
      f k _ = v where Just v = Data.Map.lookup k locals'
  setLocals $ tab

unName (Name n) = n
unNames = fmap unName
namesToPath = fmap (VString . unName)

traverse' = flip traverse

makeTable t = do
  id <- use nextId
  nextId %= (+ 1)
  objects %= Data.IntMap.insert id (OTable t)
  return id

makeFun :: Bool -> FunBody -> EvalM Int
makeFun hasSelf body@(FunBody names vararg block) = do
  env <- getLocals
  id <- use nextId
  nextId %= (+ 1)
  let body' = case hasSelf of
        True  -> (FunBody (Name "self":names) vararg block)
        False -> body
  objects %= Data.IntMap.insert id (OFun env body')
  return id

-- About inlining values: It seems it is only the last one that can
-- have multiple values:
--   local function f()
--     return 1,2
--   end
--   log_desc({f(),f()})
-- => { 1, 1, 2,  }
--   local a,b,c,d = f(), f()
--   log_desc({a=a,b=b,c=c,d=d})
-- => { 
--   c = 2,
--   a = 1,
--   b = 1,
-- }
luaConcat :: [[Value]] -> [Value]
luaConcat ll = heads ++ lastTail where
  heads = fmap Prelude.head ll
  lastTail = Prelude.last $ fmap Prelude.tail ll

  
evalStat stat = do
  -- log $ show stat
  let ni str = logn $ "Stat not implemented: " ++ str

      -- Only in 5.3 -- I don't use these.
      ev (Label name) = ni "Label"
      ev (Goto name) = ni "Goto"
      ev Break = ni "Break"

      -- Implement this in Lua syntax?
      ev (ForIn names exprs block) = ni "ForIn"

      ev (ForRange (Name name) from to Nothing block) = do
        locals' <- getLocals
        (VInt from':_) <- evalExp from
        (VInt to':_)   <- evalExp to
        let loop = \i -> do
              setVar name $ VInt i
              evalBlock block
        traverse loop [from'..to']
        stripLocals locals'
        return ()
        
      ev (If expBlocks maybeElse) = do
        -- logn $ "If: " ++ show expBlocks
        let doCases [] = return False
            doCases ((exp,block):next) = do
              (exp':_) <- evalExp exp
              if (exp' == VBool True) then
                evalBlock block >> return True
              else
                doCases next
        didCase <- doCases expBlocks
        when (not didCase) $ do
          case maybeElse of
            Just block -> do evalBlock block ; return ()
            Nothing -> return  ()
        return ()

      ev (Do block) = do
        evalBlock block
        return ()
      
      ev (While exp block) = do
        let loop = do
              (cond:_) <- evalExp exp
              when (cond == (VBool True)) $ do
                evalBlock block
                loop
        loop

      ev (Repeat block exp) = mdo
        let loop = do
              evalBlock block
              (cond:_) <- evalExp exp
              -- error $ show cond
              when (cond /= (VBool True)) loop
        loop

      ev EmptyStat = return ()

      ev (FunCall funCall) = do
        evalFunCall funCall
        return ()
  
      ev ex@(FunAssign (FunName name names maybeName) body) = do
        (fieldNames, hasSelf) <-
          case maybeName of
            Nothing -> do
              return $ (names ++ [],  False)
            Just n  -> do
              return $ (names ++ [n], True)
        id <- makeFun hasSelf body
        setVarPath name fieldNames $ VPtr id
          
      ev ex@(LocalFunAssign (Name name) body) = do
        -- logn $ "LocalFunAssign: " ++ show ex
        id <- makeFun False body
        setLocal name $ VPtr id
        
      ev ex@(LocalAssign names maybeExps) = do
        -- logn $ "LocalAssign: " ++ show ex
        vals' <- case maybeExps of
          Just exps ->
            traverse evalExp exps
          Nothing ->
            -- FIXME: Not clear.  All nil?
            return $ cycle [[VNil]]
        let vals = luaConcat vals'
            -- FIXME: Zip vars with values correct?
            nvs = Prelude.zip names vals 
        traverse' nvs $ \(Name name, val) -> setLocal name val
        return ()

      ev ex@(Assign vars exps) = do
        -- logn $ "Assign: " ++ show ex
        vals <- traverse evalExp exps
        let assign' (var, val) = assignVar var val
        traverse assign' $ Prelude.zip vars $ luaConcat vals
        return ()
      
  ev stat

assignVar (VarName (Name var)) val = setVar var val
assignVar (Select table key) val = do
  (VPtr id:_) <- evalPrefixExp table
  (key':_) <- evalExp key
  setTableField id key' val
assignVar (SelectName table (Name field)) val = do
  (VPtr id:_) <- evalPrefixExp table
  setTableField id (VString field) val

-- Variables can only have one value.  Function calls can have
-- multiple.  This is awkward.  It seems simples to always use [Value]
-- instead of Value as eval return value.
evalVar :: Var -> EvalM [Value]
evalVar var@(VarName (Name name)) = do
  val <- getVar name
  return [val]
evalVar (SelectName table (Name field)) = do
  (VPtr id:_) <- evalPrefixExp table
  val <- getTableField id (VString field)
  return [val]

evalFunCall (NormalFunCall fun args) = do
  [VPtr idFun] <- evalPrefixExp fun
  evalFun idFun Nothing args

evalFunCall (MethodCall table (Name field) args) = do
  [self@(VPtr idTable)] <- evalPrefixExp table
  VPtr idFun <- getTableField idTable (VString field) 
  evalFun idFun (Just self) args

evalFun idFun maybeSelf args = do
  -- FIXME: hasSelf
  -- FIXME: vararg
  -- FIXME: What is semantics of argument inlining for multiple return
  -- values into argument list?
  Just (OFun capturedEnv
        (FunBody names vararg block)) <- use (objects . at idFun)
  args' <- case args of
    (Args as) -> traverse evalExp as
    -- TableArg
    -- StringArg
  let
    args'' = maybeToList maybeSelf ++ luaConcat args'

  -- Switch environment and define argument bindings.
  locals' <- getLocals
  setLocals capturedEnv
  let setArg (Name name, val) = setLocal name val
  traverse setArg $ Prelude.zip names args''
  -- Evaluate the body code in the new environment.
  rvs <- evalBlock block
  -- Switch back to call site environment
  -- FIXME: The closure environment needs to be updated!
  stripLocals locals'
  return rvs

evalPrefixExp pexp =
  case pexp of
    PEVar v      -> evalVar v
    Paren e      -> evalExp e
    PEFunCall fc -> evalFunCall fc

toFloat :: Value -> Float
toFloat (VFloat f) = f
toFloat (VInt i) = fromIntegral i
toFloat v = error $ "toFloat " ++ show v
  
  

class ToValue t where toValue :: t -> Value
instance ToValue Bool  where toValue = VBool
instance ToValue Int   where toValue = VInt
instance ToValue Float where toValue = VFloat

evalExp :: Exp -> EvalM [Value]  
evalExp expr = do
  -- log $ show expr
  let ni str = do logn $ "Expr not implemented: " ++ str ; return [VNI str]

      ev Vararg = ni "Vararg"

      ev Nil = return [VNil]
      ev (Bool b) = return [VBool b]
      ev (String text) = return [VString text]

      ev (EFunDef body) = do
        id <- makeFun False body
        return [VPtr id]

      ev (Binop binop e1 e2) = do
        (e1':_) <- evalExp e1
        (e2':_) <- evalExp e2
        let op2' :: Value -> Value -> Value
            op2' = case binop of
              Add -> op2 (+)
              Sub -> op2 (-)
              Mul -> op2 (*)
              GT  -> op2b (>)
              EQ  -> op2b (==)
              NEQ -> op2b (/=)
              _ -> error "FIXME Binop"
              
            -- Note that Lua 5.3 uses integers.
            op2 :: (forall a b. Num a => a->a->a) -> Value->Value->Value
            op2 op (VInt a) (VInt b) = VInt $ op a b
            op2 op a b = VFloat $ op (toFloat a) (toFloat b)

            op2b :: (forall a b. Ord a => a->a->Bool) -> Value->Value->Value
            op2b op (VInt a) (VInt b) = VBool $ op a b
            op2b op a b = VBool $ op (toFloat a) (toFloat b)
            
            val = op2' e1' e2'
        return [val]

      ev (Unop unop e) = do
        (e':_) <- evalExp e
        let op = case unop of
              Neg -> negate
              _ -> error "FIXME Unop"
            eval1op (VInt a) = VInt $ op a
            eval1op a = VFloat $ op (toFloat a)
            val = eval1op e'
        return [val]
            
      ev ex@(Number IntNum text) = do
        -- FIXME use Data.Text.Read
        let Right (n, _) = decimal text
        return [ VInt n ]

      ev (PrefixExp pexp) = evalPrefixExp pexp

      ev (TableConst tableFields) = do
        -- [1..] as ExpField.  Then traverse evalExp and store as map.
        let -- Array fields and keyed fields are handled separately
            isField (Field _) = True ; isField _ = False
            (arrFields',keyFields) = Data.List.partition isField tableFields
            arrFields = Prelude.zip [1..] arrFields'

            -- Array values
            indexed :: (Int, TableField) -> EvalM (Value, Value)
            indexed (i, Field v) = do
              (v':_) <- evalExp v
              return (VInt i, v')

            keyed :: TableField -> EvalM (Value, Value)
            keyed (NamedField (Name k) v) = do
              (v':_) <- evalExp v
              return (VString k, v')
            keyed (ExpField k v) = do
              (k':_) <- evalExp k
              (v':_) <- evalExp v
              return (k', v')

        assIndexed <- traverse indexed arrFields
        assKeyed   <- traverse keyed   keyFields
        id <- makeTable $ Data.Map.fromList $ assIndexed ++ assKeyed  
        return $ [ VPtr id ]
        
  ev expr



-- Convert evaluator data structure back to syntax.
serialize (VFloat f) = return $ Number FloatNum $ pack $ show f
serialize (VInt i) = return $ Number IntNum $ pack $ show i
serialize (VString s) = return $ String $ pack $ show s -- FIXME?
serialize VNil = return $ Nil
serialize (VPtr id) = do
  Just obj <- use (objects . at id)
  case obj of
    (OTable table) -> do
      let field (key, val) = do
            val' <- serialize val
            -- FIXME: would be nice to also render Field but that is
            -- not strictly necessary at this point.
            case key of
              (VString name) -> do
                return $ NamedField (Name name) val'
              _ -> do
                key' <- serialize key
                return $ ExpField key' val'

      fields <- traverse field $ Data.Map.toList table
      return $ TableConst fields
    -- FIXME: Also serialize the environment
    (OFun env body) -> do
      return $ EFunDef body


-- The result of parseFile is a Block.  It seems best to focus on the
-- file level.

-- These can just be hardcoded
globals = 0
locals  = 1

runM :: EvalM t -> Result t
runM (EvalM m) = Result s l v where
  obj0 = Data.IntMap.fromList [
    (globals, OTable mempty),
    (locals,  OTable mempty)
    ]
  s0 = State 2 obj0
  ((v, l), s) = State.runState (runWriterT m) s0


pp = pPrintNoColor

test1 = do
  putStrLn "** test1"
  rv <- parseFile "../lua/test_lua_hs.lua"
  case rv of
    Right block -> do
      -- let (Result state log rv) = runM $ evalBlock block
      let (Result state log (rvs, stxs)) = runM $ do
            luaVals <- evalBlock block
            luaStxs <- traverse serialize luaVals
            return (luaVals, luaStxs)
      putStr $ log
      pp state
      pp rvs
      pp stxs
      traverse' stxs $ \stx -> do
        putStrLn $ show $ pprint stx
      return ()
      
    Left (sourceRange, msg) -> do
      putStrLn $ show sourceRange
      putStrLn $ msg

