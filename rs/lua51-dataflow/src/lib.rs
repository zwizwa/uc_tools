// FIXME: This is now defunct but can still serve as an example code
// for Rust<->Lua interfacing.

// I don't think I'm going to write the uc_tools/lua/lib/dataflow.lua
// compiler in Rust because the Lua implementation is very "dynamic"
// and too much would have to change to the point that it doesn't make
// sense to keep the patch language.  A better approach is to
// instrument the existing implementation with better error messaging
// and maybe explore the path of Lua static analysis using the
// implementations of Lua in Racket.

// As for C code generation, I think I will just continue with the
// Racket implementation because all paths I have tried these last
// couple of days are just not working out due to some kind of "grain
// boundary" problem.  The racket implementation can then be augmented
// with lessons learned in the Lua code, which is mostly about
// intefacing with existing C code, and dealing with hierarchical OSC
// parameters.

// Old comments:

// The point of this crate is to re-implement the core Rust
// functionality for the dataflow compiler derived from the original
// Lua implementation written for the headphones project.  The Lua
// wrappers are in lua51-dataflow.

// * This is not a primitive cproc generator: We assume that cprocs
// are written in C or generated by some other framework.
//
// * It however should eventually implement the cproc parallel and
// serial combinators.  The Lua code takes that approach to present
// higher level building blocks to the user.
//
// * This is NOT tagless final lib-tagless (the syntax tree is just an
// algebraic datatype)
//
// * This is NOT a canonical Rust embedding of something replacing
// cproc (see lib-causig).  That might be a compiler _target_ for code
// that would otherwise generate cproc.

// The goals here are to:

// * Get rid of the dynamically typed compiler and replace it by a
// Rust implementation that operates on algebraic data types.
//
// * Practice interfacing with Lua (I want to start doing this more
// for other code), and practice arena style memory management.

/*

Older notes

How to tackle this?

Ideas:
- Focus on data representation: Lua and Rust data structures should be equivalent
- Gradually replace functions and data structures with Rust code

Notes:
- https://crates.io/crates/mlua
- https://github.com/mlua-rs/mlua/blob/main/examples/module/src/lib.rs

Questions:
- How to expose as a Lua library?
- How to map Lua data structures to Rust data structures?


Something to start with:
- try to formalize all the name mangling variations
- wrap it in a Lua plugin so it can be integrated
- find a way to translate the Lua tables


Another idea is to completely fix the api: only the patch level is
lua, all the rest is Rust.  This would allow type checking already at
that level, as bad types are not representable in the rust side.  But
it would need userdata. https://docs.rs/mlua/latest/mlua/#custom-userdata


EDIT: I am starting directly with the "user interface", which is the
dsl exposed to lua.


Note: this is by itself ... because the state is completely abstract
and just passed around as a mut reference, and node references can
just be copied, i.e. no borrow nonsense.


2025-07-11 Some recent ideas:

- Tagless final GATs
  https://getcode.substack.com/p/efficient-extensible-expressive-typed

- State and params really do not show up in the types, they are always
  hidden to the inner composition mechanism so they are purely a
  compiler run-time thing, exposed as a compilation result (state
  struct, state init, param init and param value delivery code) next
  to the update code.



*/
#![allow(unused)]
// extern crate dataflow;
extern crate mlua;

use std::u32;

use mlua::prelude::*;
use mlua::{Error, MetaMethod, Table, UserData, UserDataFields, UserDataMethods, Value};

// use dataflow::*;

// See test.lua : two objects are needed.  One for node, one for
// compiler, and a collection of primitives are needed.  The
// primitives can be methods of compiler.

// I do want to separate the pure Rust model and the Lua interface:
// The DSL should work in Rust as well.

#[derive(Debug, Clone, Copy)]
// Nodes are always referenced by index (arena style).
struct Node(usize);
#[derive(Debug, Clone)]
struct Compiler {
    code: Vec<Syntax>,
    inputs: Vec<Node>,
}
#[derive(Debug, Clone, Copy)]
enum Syntax {
    Add(Node, Node),
    Inc(Node),
    Lit(u32),
    Input(usize),
}
impl Compiler {
    fn node(&mut self, stx: Syntax) -> Node {
        let n = self.code.len();
        self.code.push(stx);
        Node(n)
    }
    fn add(&mut self, a: Node, b: Node) -> Node {
        self.node(Syntax::Add(a, b))
    }
    fn inc(&mut self, a: Node) -> Node {
        self.node(Syntax::Inc(a))
    }

    fn input(&mut self) -> Node {
        let i = self.inputs.len();
        let n = self.node(Syntax::Input(i));
        self.inputs.push(n);
        n
    }
}

fn compiler() -> Compiler {
    Compiler {
        code: Vec::new(),
        inputs: Vec::new(),
    }
}

fn test_compiler() {
    let mut c = compiler();
    let i1 = c.input();
    let i2 = c.input();
    let t = c.add(i1, i2);
    let o = c.inc(t);
    println!("{:#?}", c);
    println!("{:#?}", o);
}

// Lua interface below

// https://docs.rs/mlua/latest/mlua/trait.UserData.html

impl UserData for Node {
    fn add_fields<F: UserDataFields<Self>>(fields: &mut F) {
        fields.add_field_method_get("id", |_, this| Ok(this.0));
    }
}
// Implementation of IntoLua is automatically provided for UserData,
// FromLua needs to be implemented manually.
impl FromLua for Node {
    fn from_lua(value: Value, lua: &Lua) -> Result<Node, LuaError> {
        match value {
            // I copied this from example.  It's a type sandwich...
            Value::UserData(ud) => Ok(*ud.borrow::<Self>()?),
            _ => unreachable!(),
        }
    }
}

// This is just for letting Lua code read a Lua representation of the
// syntax.  The Lua->Rust is via compiler methods only, no Lua data
// structure to Rust object conversion.

impl IntoLua for Syntax {
    fn into_lua(self, lua: &Lua) -> LuaResult<Value> {
        Ok(match self {
            Syntax::Input(i) => {
                let t = lua.create_table()?;
                t.push("input".into_lua(lua)?);
                t.push(Value::Number(i as f64));
                Value::Table(t)
            }
            Syntax::Add(Node(a), Node(b)) => {
                let t = lua.create_table()?;
                t.push("add".into_lua(lua)?);
                t.push(a);
                t.push(b);
                Value::Table(t)
            }
            Syntax::Inc(Node(a)) => {
                let t = lua.create_table()?;
                t.push("inc".into_lua(lua)?);
                t.push(a);
                Value::Table(t)
            }
            Syntax::Lit(num) => Value::Number(num as f64),
        })
    }
}

impl UserData for Compiler {
    fn add_fields<F: UserDataFields<Self>>(fields: &mut F) {
        fields.add_field_method_get("code", |_, this| Ok(this.code.clone()));
        fields.add_field_method_get("inputs", |_, this| Ok(this.inputs.clone()));
    }
    // All DSL operations will be methods taking a set of nodes and producing a node.
    fn add_methods<M: UserDataMethods<Self>>(methods: &mut M) {
        methods.add_method_mut(
            "add",
            |_, mut this, (a, b): (Node, Node)| Ok(this.add(a, b)),
        );
        methods.add_method_mut("inc", |_, mut this, a: Node| Ok(this.inc(a)));
        methods.add_method_mut("input", |_, mut this, (): ()| Ok(this.input()));
    }
}

fn new_compiler(_: &Lua, (): ()) -> LuaResult<Compiler> {
    Ok(compiler())
}

fn test_internal(_: &Lua, _: ()) -> LuaResult<()> {
    test_compiler();
    Ok(())
}

fn sum(_: &Lua, (a, b): (i64, i64)) -> LuaResult<i64> {
    Ok(a + b)
}

fn used_memory(lua: &Lua, _: ()) -> LuaResult<usize> {
    Ok(lua.used_memory())
}

#[mlua::lua_module]
fn dataflow_rs(lua: &Lua) -> LuaResult<LuaTable> {
    let exports = lua.create_table()?;
    exports.set("test_internal", lua.create_function(test_internal)?)?;
    exports.set("sum", lua.create_function(sum)?)?;
    exports.set("used_memory", lua.create_function(used_memory)?)?;

    exports.set("input123", Syntax::Input(123))?;
    exports.set("add", Syntax::Add(Node(1), Node(2)));

    exports.set("new_compiler", lua.create_function(new_compiler)?)?;

    Ok(exports)
}
